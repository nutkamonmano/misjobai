<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MIS Job Request AI Agent Chatbot</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Sarabun', sans-serif;
    }

    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 3px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .typing-indicator {
      display: flex;
      align-items: center;
      padding: 10px 0;
    }

    .typing-indicator span {
      height: 8px;
      width: 8px;
      background-color: #9ca3af;
      border-radius: 50%;
      display: inline-block;
      margin: 0 2px;
      animation: bounce 1.4s infinite ease-in-out both;
    }

    .typing-indicator span:nth-child(1) {
      animation-delay: -0.32s;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: -0.16s;
    }

    @keyframes bounce {

      0%,
      80%,
      100% {
        transform: scale(0);
      }

      40% {
        transform: scale(1.0);
      }
    }

    /* อ่าน Markdown ให้สวยขึ้น */
    .markdown-body p {
      margin: 0.5rem 0;
    }

    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4,
    .markdown-body h5,
    .markdown-body h6 {
      font-weight: 700;
      margin: 0.75rem 0 0.5rem;
    }

    .markdown-body code {
      padding: 0.15rem 0.3rem;
      background: #f3f4f6;
      border-radius: 4px;
    }

    .markdown-body pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem;
      border-radius: 8px;
      overflow: auto;
    }

    .markdown-body pre code {
      background: transparent;
      color: inherit;
      padding: 0;
    }

    .markdown-body ul,
    .markdown-body ol {
      padding-left: 1.25rem;
      margin: 0.5rem 0;
    }

    .markdown-body .table-wrapper {
      width: 100%;
      overflow-x: auto;
      padding-bottom: 0.75rem;
    }

    .markdown-body table {
      width: 100%;
      min-width: clamp(520px, 85vw, 1120px);
      border-collapse: separate;
      border-spacing: 0;
      margin: 1rem 0;
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
    }

    .markdown-body thead tr {
      background: #0f172a;
      color: #f8fafc;
    }

    .markdown-body thead th {
      padding: 0.85rem 1.15rem;
      font-size: 0.95rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .markdown-body tbody td {
      padding: 0.85rem 1.15rem;
      font-size: 0.92rem;
      color: #1f2937;
      border-top: 1px solid #e2e8f0;
      vertical-align: top;
    }

    .markdown-body tbody td p:first-child,
    .markdown-body tbody td ul:first-child,
    .markdown-body tbody td ol:first-child {
      margin-top: 0;
    }

    .markdown-body tbody td p:last-child,
    .markdown-body tbody td ul:last-child,
    .markdown-body tbody td ol:last-child {
      margin-bottom: 0;
    }

    .markdown-body tbody tr:last-child td {
      border-bottom: none;
    }

    .markdown-body tbody tr:nth-child(even) td {
      background: #f8fafc;
    }

    .markdown-body tbody td strong {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background: #0f172a;
      color: #f8fafc;
      letter-spacing: 0.015em;
    }

    .markdown-body table thead th:first-child {
      border-top-left-radius: 14px;
    }

    .markdown-body table thead th:last-child {
      border-top-right-radius: 14px;
    }

    .markdown-body table tbody tr:last-child td:first-child {
      border-bottom-left-radius: 14px;
    }

    .markdown-body table tbody tr:last-child td:last-child {
      border-bottom-right-radius: 14px;
    }

    .markdown-body blockquote {
      border-left: 4px solid #e5e7eb;
      padding-left: 0.75rem;
      color: #6b7280;
      margin: 0.5rem 0;
    }

    @media (max-width: 640px) {
      .markdown-body table {
        min-width: 100%;
      }

      .markdown-body thead th {
        padding: 0.7rem 0.85rem;
        font-size: 0.85rem;
      }

      .markdown-body tbody td {
        padding: 0.7rem 0.85rem;
        font-size: 0.86rem;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body class="bg-gray-200 flex items-center justify-center h-screen">
  <div
    class="flex flex-col h-full md:h-[90vh] lg:h-[92vh] w-full max-w-4xl lg:max-w-5xl xl:max-w-6xl bg-white shadow-2xl rounded-lg">
    <header class="p-4 border-b bg-gray-50 rounded-t-lg">
      <h1 class="text-xl font-bold text-gray-800 text-center">MIS Job Request AI Agent Chatbot</h1>
    </header>

    <main id="chatbox" class="flex-1 p-6 overflow-y-auto custom-scrollbar">
      <div class="flex gap-3 my-4 text-gray-600 text-sm">
        <div class="flex-shrink-0">
          <svg class="w-8 h-8 bg-blue-500 text-white p-1.5 rounded-full" xmlns="http://www.w3.org/2000/svg" fill="none"
            viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M8.25 3v1.5M4.5 8.25H3m18 0h-1.5M4.5 12H3m18 0h-1.5m-15 3.75H3m18 0h-1.5M8.25 19.5V21M12 3v1.5m0 15V21m3.75-18v1.5m0 15V21m-9-1.5h10.5a2.25 2.25 0 0 0 2.25-2.25V6.75a2.25 2.25 0 0 0-2.25-2.25H6.75A2.25 2.25 0 0 0 4.5 6.75v10.5a2.25 2.25 0 0 0 2.25 2.25Zm.75-12h9v9h-9v-9Z" />
          </svg>
        </div>
        <div class="leading-relaxed bg-gray-100 p-4 rounded-r-lg rounded-bl-lg">
          <span class="block font-bold text-gray-700">AI Assistant</span>
          <p>สวัสดีครับ! ลองถามผมเกี่ยวกับเอกสารคำขอได้เลย พร้อมตอบเสมอครับ</p>
        </div>
      </div>
    </main>

    <div id="prompt-suggestions-container" class="p-4 pt-0 pb-3 border-t border-gray-100"></div>

    <footer class="p-4 border-t bg-gray-50 rounded-b-lg">
      <form id="chat-form" class="flex items-center gap-3">
        <textarea id="chat-input" placeholder="พิมพ์ข้อความของคุณที่นี่..."
          class="flex-1 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:outline-none"
          rows="1"></textarea>
        <button type="submit" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 disabled:bg-blue-300">
          <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="w-6 h-6" viewBox="0 0 24 24">
            <path
              d="M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z" />
          </svg>
        </button>
      </form>
    </footer>
  </div>

  <script>
    // ====== Config ======
    // const API_URL = 'http://misdocker.metrosystems.co.th:5678/webhook/misjobreq';
    // const API_URL = 'http://misdocker.metrosystems.co.th:5678/webhook-test/misjobreq';
    // const API_URL = "https://bambot.metrosystems.co.th/webhook-test/mistest";
    const API_URL = "http://misdockerdev.metrosystems.co.th:5678/webhook/mistest2";
    const sessionId = crypto.randomUUID();
    const TRUSTED_HTML_HOSTS = [new URL(API_URL).hostname];

    const prompts = [
      "ขอดูรายละเอียดงาน",
      "ปริมาณงานรายวัน",
      "ปริมาณงานรายเดือน",
      "ปริมาณงานทั้งหมดในปีนี้",
      "งานประเภทไหนถูกขอเข้ามาเยอะที่สุด",
      "คาดการณ์ปริมาณ 4 สัปดาห์ถัดไป",
      "แผนกไหนขอเยอะสุด",
      "พนักงานขายคนนับจำนวนงานในแต่ละสถานะแบบรายวัน",
    ];
    const PROMPT_COUNT = 4;

    // ====== Elements ======
    const chatbox = document.getElementById("chatbox");
    const chatForm = document.getElementById("chat-form");
    const chatInput = document.getElementById("chat-input");
    const submitButton = chatForm.querySelector("button");
    const promptSuggestionsContainer = document.getElementById("prompt-suggestions-container");

    // ====== Events ======
    chatForm.addEventListener("submit", handleFormSubmit);
    chatInput.addEventListener("input", adjustTextareaHeight);
    chatInput.addEventListener("keydown", handleEnterPress);
    window.addEventListener("DOMContentLoaded", renderInitialPrompts);

    // ====== Random helpers ======
    function cryptoRandom() { const u = new Uint32Array(1); crypto.getRandomValues(u); return u[0] / (0xffffffff + 1); }
    function shuffleArray(arr) { const a = arr.slice(); for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(cryptoRandom() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; }
    function pickRandomN(arr, n) { if (n >= arr.length) return shuffleArray(arr); const s = shuffleArray(arr); return s.slice(0, n); }

    function renderInitialPrompts() {
      if (!promptSuggestionsContainer) return;
      const selected = pickRandomN(prompts, PROMPT_COUNT);
      const wrapper = document.createElement("div");
      wrapper.className = "flex flex-wrap justify-center gap-2";
      selected.forEach((text) => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "bg-gray-100 text-gray-800 text-sm py-2 px-3 rounded-full hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-400";
        b.textContent = text;
        b.addEventListener("click", () => sendMessage(text));
        wrapper.appendChild(b);
      });
      promptSuggestionsContainer.innerHTML = "";
      promptSuggestionsContainer.appendChild(wrapper);
    }

    async function handleFormSubmit(e) {
      e.preventDefault();
      const userInput = chatInput.value.trim();
      if (!userInput) return;
      sendMessage(userInput);
      chatInput.value = "";
      adjustTextareaHeight();
    }

    // ====== Core fetch & dispatch ======
    async function sendMessage(chatInputVal) {
      addMessageToChatbox(chatInputVal, "user");

      const typingIndicatorId = showTypingIndicator();
      toggleForm(false);

      try {
        const response = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json, text/markdown;q=0.9, text/plain;q=0.8, text/html;q=0.7",
          },
          body: JSON.stringify({ chatInput: chatInputVal, sessionId }),
        });

        const contentType = (response.headers.get("content-type") || "").toLowerCase();
        const textBody = await safeReadText(response);

        removeMessageById(typingIndicatorId);

        if (!response.ok) {
          addMessageToChatbox(
            `เกิดข้อผิดพลาดจากเซิร์ฟเวอร์ (${response.status}): ${textBody || "No details"}`,
            "bot",
            { format: "text" }
          );
          return;
        }

        if (contentType.includes("application/json")) {
          let parsed = null;
          try { parsed = JSON.parse(textBody); } catch { parsed = null; }
          if (!parsed) { addMessageToChatbox(textBody || "ไม่สามารถอ่าน JSON ได้", "bot", { format: "text" }); return; }
          displayFromJson(parsed);
          return;
        }

        if (contentType.includes("text/markdown")) { displayMarkdown(textBody); return; }

        if (contentType.includes("text/html")) {
          if (isTrustedHtmlSource(API_URL)) addMessageToChatbox(textBody, "bot", { format: "html" });
          else addMessageToChatbox(textBody, "bot", { format: "text" });
          return;
        }

        // text/plain หรืออื่น ๆ → ลองเดา markdown ก่อน
        if (looksLikeMarkdown(textBody)) displayMarkdown(textBody);
        else addMessageToChatbox(textBody, "bot", { format: "text" });

      } catch (error) {
        console.error("Error fetching API:", error);
        removeMessageById(typingIndicatorId);
        addMessageToChatbox("ขออภัยครับ เกิดข้อผิดพลาดในการเชื่อมต่อกับเซิร์ฟเวอร์ โปรดลองอีกครั้งในภายหลัง", "bot", { format: "text" });
      } finally {
        toggleForm(true);
        chatInput.focus();
      }
    }

    // ====== Renderers ======
    function displayMarkdown(markdown) {
      addMessageToChatbox(markdown, "bot", { format: "markdown" });
    }

    function displayFromJson(result) {
      // priority: markdown/html/message
      if (typeof result?.markdown === "string") displayMarkdown(result.markdown);
      if (typeof result?.html === "string") {
        if (isTrustedHtmlSource(API_URL)) addMessageToChatbox(result.html, "bot", { format: "html" });
        else addMessageToChatbox(result.html, "bot", { format: "text" });
      }
      if (typeof result?.message === "string") {
        const msg = result.message.trim();
        if (looksLikeMarkdown(msg)) displayMarkdown(msg);
        else addMessageToChatbox(msg, "bot", { format: "text" });
      }
      if (typeof result?.md === "string") displayMarkdown(result.md);
      if (typeof result?.content === "string" && looksLikeMarkdown(result.content)) displayMarkdown(result.content);

      // table-like
      if (Array.isArray(result)) {
        const t = createDynamicTable(normalizeArrayToObjects(result));
        if (t) addMessageToChatbox(t, "bot", { format: "html" });
        return;
      }
      if (Array.isArray(result.data) && result.data.length > 0) {
        const t = createDynamicTable(normalizeArrayToObjects(result.data));
        if (t) addMessageToChatbox(t, "bot", { format: "html" });
        return;
      }
      if (Array.isArray(result.rows)) {
        const rows = result.rows;
        const columns = Array.isArray(result.columns) ? result.columns : inferColumnsFromRows(rows);
        const objects = rowsAsObjects(rows, columns);
        const t = createDynamicTable(objects, { columns });
        if (t) addMessageToChatbox(t, "bot", { format: "html" });
        return;
      }

      if (result && typeof result === "object" && !result.markdown && !result.html && !result.message) {
        const pretty = `<pre class="whitespace-pre-wrap text-xs bg-gray-50 p-3 rounded">${escapeHtml(JSON.stringify(result, null, 2))}</pre>`;
        addMessageToChatbox(pretty, "bot", { format: "html" });
      }
    }

    function createDynamicTable(data, opts = {}) {
      if (!Array.isArray(data) || data.length === 0) return "";
      const headers = Array.isArray(opts.columns) && opts.columns.length ? opts.columns : Object.keys(data[0]);
      const headerRow = headers.map(h => {
        const label = String(h).replace(/_/g, " ").trim();
        return `<th>${escapeHtml(label)}</th>`;
      }).join("");
      const bodyRows = data.map(row => {
        const cells = headers.map(h => `<td>${renderTableCellValue(row[h])}</td>`).join("");
        return `<tr>${cells}</tr>`;
      }).join("");

      return `
        <div class="table-wrapper">
          <table class="rich-table">
            <thead><tr>${headerRow}</tr></thead>
            <tbody>${bodyRows}</tbody>
          </table>
        </div>`;
    }

    // ====== Helpers ======
    const escapeMap = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
    function escapeHtml(str) { return String(str).replace(/[&<>"']/g, ch => escapeMap[ch]); }

    function enhanceStructuredContent(input, options = {}) {
      const raw = typeof input === "string" ? input : String(input || "");
      if (!raw || options.skipEnhance) return { output: raw, changed: false };

      const transforms = [transformDateListToMarkdown, transformKeyValueListToMarkdown];
      let output = raw;
      let changed = false;

      transforms.forEach(fn => {
        const res = fn(output);
        if (res && res.changed) {
          output = res.output;
          changed = true;
        }
      });

      return { output, changed };
    }

    function transformDateListToMarkdown(input) {
      const raw = typeof input === "string" ? input : String(input || "");
      const normalizedRaw = raw.replace(/;\s*(?=[\"'`\u201C\u201D\u2018\u2019>*\-\s]*วันที่\s+\d{4}-\d{2}-\d{2})/g, "\n");
      const lines = normalizedRaw.split(/\r?\n/);
      const result = [];
      let buffer = [];
      let changed = false;

      function matchDateLine(line) {
        const trimmed = line.trim();
        if (!trimmed) return null;
        const match = trimmed.match(/^[\"'`\u201C\u201D\u2018\u2019>*\-\s]*วันที่\s+(\d{4}-\d{2}-\d{2})\s*(?:[:\-]\s*)?([\d,.]+)\s*รายการ\s*[\"'`\u201C\u201D\u2018\u2019]*[;,.。、]?\s*$/i);
        if (!match) return null;
        return { date: match[1], count: match[2].replace(/\s+/g, "") };
      }

      function flushBuffer() {
        if (buffer.length >= 2) {
          if (result.length && result[result.length - 1].trim() !== "") result.push("");
          result.push("| วันที่ | จำนวนรายการ |");
          result.push("| --- | --- |");
          buffer.forEach(item => {
            result.push(`| ${item.date} | ${item.count} |`);
          });
          result.push("");
          changed = true;
        } else {
          buffer.forEach(item => result.push(item.original));
        }
        buffer = [];
      }

      lines.forEach(line => {
        const hit = matchDateLine(line);
        if (hit) buffer.push({ original: line, ...hit });
        else {
          flushBuffer();
          result.push(line);
        }
      });
      flushBuffer();

      return { output: result.join("\n"), changed };
    }

    function transformKeyValueListToMarkdown(input) {
      const raw = typeof input === "string" ? input : String(input || "");
      if (!raw) return { output: raw, changed: false };

      const normalized = raw.replace(/;\s*(?=[\"'`\u201C\u201D\u2018\u2019\(\[]?[A-Za-z\u0E00-\u0E7F0\d]+\s*[:：])/g, "\n");
      const lines = normalized.split(/\r?\n/);
      const result = [];
      let buffer = [];
      let changed = false;

      function matchLine(line) {
        const trimmed = line.trim();
        if (!trimmed || /^\|/.test(trimmed)) return null;
        if (/[=<>]/.test(trimmed) || trimmed.includes("::")) return null;
        const sqlKeywords = /(SELECT|FROM|WHERE|JOIN|GROUP BY|ORDER BY|INSERT|UPDATE|DELETE|WITH|HAVING|UNION|LIMIT)\b/i;
        if (sqlKeywords.test(trimmed)) return null;
        const match = trimmed.match(/^[\"'`\u201C\u201D\u2018\u2019\(\[]*([^:：]+?)\s*[:：]\s*(.+?)\s*[\"'`\u201C\u201D\u2018\u2019\)\]]*$/);
        if (!match) return null;
        const label = match[1].trim();
        let value = match[2].trim();
        if (!label || !value) return null;
        value = value.replace(/\s*[;,.。、]+$/, "").trim();
        if (!label || !value) return null;
        return { label, value, original: line };
      }

      function flushBuffer() {
        if (buffer.length >= 2) {
          if (result.length && result[result.length - 1].trim() !== "") result.push("");
          result.push("| รายการ | ค่า |");
          result.push("| --- | --- |");
          buffer.forEach(item => {
            result.push(`| ${item.label} | ${item.value} |`);
          });
          result.push("");
          changed = true;
        } else {
          buffer.forEach(item => result.push(item.original));
        }
        buffer = [];
      }

      lines.forEach(line => {
        const hit = matchLine(line);
        if (hit) buffer.push(hit);
        else {
          flushBuffer();
          result.push(line);
        }
      });
      flushBuffer();

      return { output: result.join("\n"), changed };
    }

    function renderMarkdownToHtml(markdown, opts = {}) {
      const mdRaw = typeof markdown === "string" ? markdown : String(markdown || "");
      const enhanced = opts.skipEnhance ? { output: mdRaw, changed: false } : enhanceStructuredContent(mdRaw);
      const source = enhanced.output;
      if (window.marked && typeof marked.parse === "function") {
        if (renderMarkdownToHtml._configured !== true && typeof marked.setOptions === "function") {
          marked.setOptions({ mangle: false, headerIds: false, breaks: true });
          renderMarkdownToHtml._configured = true;
        }
        return wrapTables(marked.parse(source));
      }
      return wrapTables(escapeHtml(source).replace(/\n/g, "<br>"));
    }
    function renderContentByFormat(content, format) {
      const raw = content == null ? "" : String(content);
      switch (format) {
        case "markdown":
          return renderMarkdownToHtml(raw);
        case "text":
          {
            const enhanced = enhanceStructuredContent(raw);
            if (enhanced.changed) return renderMarkdownToHtml(enhanced.output, { skipEnhance: true });
            return escapeHtml(raw).replace(/\n/g, "<br>");
          }
        default:
          return raw;
      }
    }

    function renderTableCellValue(value) {
      if (value == null) return "";

      if (Array.isArray(value)) {
        const normalized = normalizeArrayToObjects(value);
        if (Array.isArray(normalized) && normalized.length) {
          const nested = createDynamicTable(normalized);
          if (nested) return nested;
        }
        try { return escapeHtml(JSON.stringify(value)); } catch { return escapeHtml(String(value)); }
      }

      if (typeof value === "number") {
        let formatted = value;
        try { formatted = value.toLocaleString("th-TH", { maximumFractionDigits: 2 }); } catch { }
        return escapeHtml(String(formatted));
      }

      if (typeof value === "object") {
        try {
          return `<pre class="whitespace-pre-wrap text-xs bg-gray-50 p-2 rounded">${escapeHtml(JSON.stringify(value, null, 2))}</pre>`;
        } catch {
          return escapeHtml(String(value));
        }
      }

      const str = String(value);
      const enhanced = enhanceStructuredContent(str);
      if (enhanced.changed) {
        return renderMarkdownToHtml(enhanced.output, { skipEnhance: true });
      }
      if (looksLikeMarkdown(str)) {
        return renderMarkdownToHtml(str);
      }
      return escapeHtml(str);
    }

    // เดา markdown จาก pattern พื้นฐาน
    function looksLikeMarkdown(s) {
      if (!s) return false;
      return /(^|\n)\s{0,3}#{1,6}\s|(\*\*.+\*\*)|(_.+_)|`{1,3}[^`]+`{1,3}|(^|\n)\s*[-*+]\s+|(^|\n)\s*\d+\.\s+|\|.*\|/m.test(s);
    }

    function addMessageToChatbox(content, sender, options = {}) {
      const id = `msg-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
      const el = document.createElement("div");
      el.id = id;
      const format = options.format || (sender === "user" ? "text" : "markdown");
      const safeContent = renderContentByFormat(content, format);

      if (sender === "user") {
        el.innerHTML = `
          <div class="flex justify-end gap-3 my-4 text-gray-600 text-sm">
            <div class="leading-relaxed bg-blue-100 p-4 rounded-l-lg rounded-br-lg max-w-full overflow-x-auto">
              <span class="block font-bold text-gray-700">คุณ</span>
              <div class="whitespace-pre-wrap">${safeContent}</div>
            </div>
            <div class="flex-shrink-0">
              <svg class="w-8 h-8 bg-gray-600 text-white p-1.5 rounded-full" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0ZM4.501 20.118a7.5 7.5 0 0 1 14.998 0A17.933 17.933 0 0 1 12 21.75c-2.676 0-5.216-.584-7.499-1.632Z" />
              </svg>
            </div>
          </div>`;
      } else {
        el.innerHTML = `
          <div class="flex gap-3 my-4 text-gray-600 text-sm">
            <div class="flex-shrink-0">
              <svg class="w-8 h-8 bg-blue-500 text-white p-1.5 rounded-full" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 3v1.5M4.5 8.25H3m18 0h-1.5M4.5 12H3m18 0h-1.5m-15 3.75H3m18 0h-1.5M8.25 19.5V21M12 3v1.5m0 15V21m3.75-18v1.5m0 15V21m-9-1.5h10.5a2.25 2.25 0 0 0 2.25-2.25V6.75a2.25 2.25 0 0 0-2.25-2.25H6.75A2.25 2.25 0 0 0 4.5 6.75v10.5a2.25 2.25 0 0 0 2.25 2.25Zm.75-12h9v9h-9v-9Z" />
              </svg>
            </div>
            <div class="leading-relaxed bg-gray-100 p-4 rounded-r-lg rounded-bl-lg max-w-full overflow-x-auto">
              <span class="block font-bold text-gray-700">AI Assistant</span>
              <div class="markdown-body">${safeContent}</div>
            </div>
          </div>`;
      }

      chatbox.appendChild(el);
      scrollToBottom();
      return id;
    }

    function showTypingIndicator() {
      const content = `<div class="typing-indicator"><span></span><span></span><span></span></div>`;
      return addMessageToChatbox(content, "bot", { format: "html" });
    }
    function removeMessageById(id) { const m = document.getElementById(id); if (m) m.remove(); }
    function toggleForm(isEnabled) { chatInput.disabled = !isEnabled; submitButton.disabled = !isEnabled; }
    function scrollToBottom() { chatbox.scrollTop = chatbox.scrollHeight; }
    function adjustTextareaHeight() { chatInput.style.height = "auto"; chatInput.style.height = chatInput.scrollHeight + "px"; }
    function handleEnterPress(e) { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); chatForm.requestSubmit(); } }
    async function safeReadText(response) { try { return await response.text(); } catch { return ""; } }
    function isTrustedHtmlSource(urlStr) { try { const host = new URL(urlStr).hostname; return TRUSTED_HTML_HOSTS.includes(host); } catch { return false; } }

    // table helpers
    function inferColumnsFromRows(rows) {
      if (!rows.length) return [];
      if (Array.isArray(rows[0])) { const maxLen = Math.max(...rows.map(r => r.length)); return Array.from({ length: maxLen }, (_, i) => `col_${i + 1}`); }
      const set = new Set(); rows.forEach(r => Object.keys(r || {}).forEach(k => set.add(k))); return Array.from(set);
    }
    function rowsAsObjects(rows, columns) {
      if (!rows.length) return [];
      if (!Array.isArray(rows[0])) return rows;
      return rows.map(r => { const o = {}; columns.forEach((c, i) => o[c] = r[i]); return o; });
    }
    function normalizeArrayToObjects(arr) {
      if (!arr.length) return arr;
      if (Array.isArray(arr[0])) { const cols = inferColumnsFromRows(arr); return rowsAsObjects(arr, cols); }
      if (typeof arr[0] === "object" && arr[0] !== null) return arr;
      return arr.map(v => ({ value: v }));
    }

    function wrapTables(html) {
      if (typeof html !== "string" || !html.includes("<table")) return html;
      return html.replace(/<table[\s\S]*?<\/table>/g, (tableMarkup) => {
        if (/\btable-wrapper\b/.test(tableMarkup)) return tableMarkup;
        return `<div class="table-wrapper">${tableMarkup}</div>`;
      });
    }
  </script>
</body>

</html>